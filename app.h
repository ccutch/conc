/** app.h - A framework for building high performance web apps.

    Overview
    ========

    This library provides a foundation for any of my future web apps.
    It features a cooperative runtime with non-blocking I/O, memory 
    management based on arena allocation, an HTML templating engine,
    and a database to store easily transferable data.


    Table of Contents:
    ===================

    Heading  ---- Provides a high level overview of the project and sets up a
                  convienent way to turn on all features of the library.

    Memory ------ Provides a memory management system that is based on arena
                  allocation, and tools for viewing and manipulating memory.

    Runtime ----- Provides a cooperative runtime for our application for
                  managing memory and handling multiple processes at once.

    DataTypes --- Provides a set of data types that are used to marshall and
                  unmarshall data from the database, templates, and APIs.

    System ------ Provides low level integration with the os for system calls,
                  non-blocking file I/O, and environment variables.

    Network ----- Provides non-blocking tcp server, a basic HTTP interface, and
                  a path based router for handling incoming requests.

    Database ---- Provides a wrapper around the sqlite3 library to store data in
                  a unstructured way with documents-based storage.

    Template ---- Provides a templating engine that will allow us to generate
                  HTML from our data structures, inspired by Go.
           
    Application - Provides a high level interface for starting our application,
                  binding data, serving files and folders.


    @author:  Connor McCutcheon <connor.mccutcheon95@gmail.com>
    @date:    2025-03-01
    @version  0.1.0
    @license: MIT
*/


#ifdef APP_IMPLEMENTATION
    #define MEMORY_IMPLEMENTATION
    #define RUNTIME_IMPLEMENTATION
    #define DATATYPES_IMPLEMENTATION
    #define SYSTEM_IMPLEMENTATION
    #define NETWORK_IMPLEMENTATION
    #define DATABASE_IMPLEMENTATION
    #define TEMPLATE_IMPLEMENTATION
    #define APPLICATION_IMPLEMENTATION
#endif


////////////////////////////////////////////////////////
//                                                    //
//   ╔════════════════════════════════════════════╗   //
//   ║                                            ║   //
//   ║              >>> WARNING <<<               ║   //
//   ║                                            ║   //
//   ║   This file is automatically generated.    ║   //
//   ║                                            ║   //
//   ║   ═══════ Do not edit this file ════════   ║   //
//   ║                                            ║   //
//   ║   Instead edit files in source directory   ║   //
//   ║   and run `./nob` to rebuild this file.    ║   //
//   ║                                            ║   //
//   ║   The build system will concatinate all    ║   //
//   ║   header files into one `app.h` file.      ║   //
//   ║                                            ║   //
//   ╚════════════════════════════════════════════╝   //
//                                                    //
////////////////////////////////////////////////////////


/** memory.h - Provides a region based memory system for storing data.

    @author:  Connor McCutcheon <connor.mccutcheon95@gmail.com>
    @date:    2025-03-01
    @version  0.1.0 
    @license: MIT
*/


#ifndef MEMORY_HEADER
#define MEMORY_HEADER


#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <unistd.h>


// Record for tracking allocated blocks of memory
typedef struct MemoryBlock {
    struct MemoryBlock* next;
    char* ptr;
    int size;
} MemoryBlock;

// Based on tsoding's Arena Memory Allocator
//    https://github.com/tsoding/arena
typedef struct MemoryArena {
    struct MemoryArena* next;
    int capacity;
    int count;
    MemoryBlock *blocks;
    char memory[];
} MemoryArena;

// Create a new globally allocated MemoryArena
MemoryArena* memory_arena(int capacity);

// Count the number of blocks in the arena
int memory_block_count(MemoryArena* arena);

// Allocate a new chunk of memory in an arena
void* memory_alloc(MemoryArena* arena, int size);

// Reallocate memory to a new, larger page
void* memory_realloc(MemoryArena* arena, void* ptr, int size);

// Empty all contents of the arena
void memory_empty(MemoryArena* arena);

// Destroy an arena and all of its children
void memory_destroy(MemoryArena* arena);


#define MEMORY_DEFUALT_ARENA_SIZE getpagesize()
#define MEMORY_DEFAULT_SLICE_SIZE 100

// Macro for dynamically sized arrays
#define MEMORY_SLICE(name, type) \
    struct name {                \
        int capacity;            \
        int count;               \
        type* items;             \
    }

// Append a new item to the end of the slice
#define memory_slice_append(arena, slice, item) ({         \
    if ((slice)->count >= (slice)->capacity) {             \
        (slice)->capacity += MEMORY_DEFAULT_SLICE_SIZE;    \
        int size = (slice)->capacity * sizeof(item);       \
        (slice)->items = realloc((slice)->items, size);    \
        if ((slice)->items == NULL) {                      \
            perror("[ERROR] Failed to allocate memory\n"); \
            exit(1);                                       \
        }                                                  \
    }                                                      \
    (slice)->items[(slice)->count++] = (item);             \
})

// Remove an item from slice, and replace with last item
#define memory_slice_remove(slice, index) ({                  \
    if ((index) >= (slice)->count) {                          \
        perror("[ERROR] Index out of bounds\n");              \
        exit(1);                                              \
    }                                                         \
    (slice)->items[index] = (slice)->items[--(slice)->count]; \
})


#ifdef MEMORY_IMPLEMENTATION


#include <string.h>
#include <sys/mman.h>


MemoryArena* memory_arena(int capacity)
{
    MemoryArena* arena = mmap(NULL, sizeof(MemoryArena) + sizeof(char) * capacity,
                              PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    arena->count = 0;
    arena->capacity = capacity;
    memset(arena->memory, 0, capacity);
    arena->blocks = NULL;
    return arena;
}


int memory_block_count(MemoryArena* arena)
{
    int count = 0;
    for (MemoryBlock* alloc = arena->blocks; alloc != NULL; alloc = alloc->next)
        count++;
    return count;
}


void* memory_alloc(MemoryArena* arena, int size)
{
    // Sensible default to malloc memory
    if (arena == NULL) return malloc(size);

    // Search arena for available memory
    while (arena->count + size > arena->capacity && arena->next != NULL)
        arena = arena->next;
    
    // Allocate memory if none was found
    if (arena->count + size > arena->capacity) {

        // Allocating the right capacity
        int capacity = (arena->capacity > size) ? arena->capacity : size;
        arena->next = memory_arena(capacity*2);
        if (arena->next == NULL) return NULL;
        arena = arena->next;

    }

    // Recording allocation to the stack
    MemoryBlock* alloc = malloc(sizeof(MemoryBlock));
    alloc->ptr = &arena->memory[arena->count];
    alloc->size = size;
    alloc->next = arena->blocks;
    arena->count += size;
    arena->blocks = alloc;
    return alloc->ptr;
}


void* memory_realloc(MemoryArena* arena, void* ptr, int size)
{
    if (arena == NULL) return realloc(ptr, size);

    MemoryBlock *alloc = arena->blocks;
    while (alloc != NULL && alloc->ptr != ptr)
        alloc = alloc->next;

    if (alloc == NULL) return NULL;
    if (alloc->size == size) return ptr;
    if (alloc->size > size) return ptr;

    void* new = memory_alloc(arena, size);
    if (new == NULL) return NULL;

    char* source = (char*)ptr;
    char* sink = (char*)new;

    for (int i = 0; i < alloc->size; i++)
        sink[i] = source[i];

    return new;
}


void memory_empty(MemoryArena* arena)
{
    if (arena == NULL) return;

    // Smash the Bureaucracy
    while (arena->blocks != NULL) {

        MemoryBlock* alloc = arena->blocks;
        arena->blocks = alloc->next;
        free(alloc);

    }

    // Destroy the Bloodline
    MemoryArena* child = arena->next;
    while (child != NULL) {

        child = child->next;
        memory_destroy(child);

    }

    // And Salt the Earth
    arena->next = NULL;
    arena->count = 0;
    arena->blocks = NULL;
    memset(arena->memory, 0, arena->capacity);
}


void memory_destroy(MemoryArena* arena)
{
    if (arena == NULL) return;

    // Smash the Bureaucracy
    while (arena->blocks != NULL) {

        MemoryBlock* alloc = arena->blocks;
        arena->blocks = alloc->next;
        free(alloc);

    }

    // Destroy the Bloodline
    MemoryArena* child = arena->next;
    while (child != NULL) {

        child = child->next;
        memory_destroy(child);

    }

    // And off with the head
    munmap(arena, sizeof(MemoryArena) + sizeof(char)*arena->capacity);
}


#endif // MEMORY_IMPLEMENTATION
#endif // MEMORY_HEADER

/** runtime.h - Provides a cooperative runtime for our application.

    @author:  Connor McCutcheon <connor.mccutcheon95@gmail.com>
    @date:    2025-03-03
    @version  0.1.0 
    @license: MIT  
*/


#ifndef RUNTIME_HEADER
#define RUNTIME_HEADER


#include <unistd.h>


#define RUNTIME_FIBER_STACK_SIZE 8 * getpagesize()


typedef struct RuntimeFiber {

    // Fiber state for context switching
    void* stack_pointer;
    void* registers;

    // Memory tied to the lifetime of the fiber
    MemoryArena* memory;

} RuntimeFiber;


int runtime_main(void);

int runtime_id(void);

void* runtime_alloc(int size);

int runtime_unblock_fd(int);

void runtime_start(void (*fn)(void*), void *arg);

void runtime_yield(void);

void runtime_read(int fd);

void runtime_write(int fd);

void runtime_resume(void* ptr);

void runtime_next(void);

void runtime_stop(void);

char* runtime_sprintf(char *, ...);

void runtime_logf(char *, ...);


#define runtime_run(fn) ({ \
    void __runtime_proc__(void) { fn; } \
    runtime_start((void*)__runtime_proc__, NULL); \
})


#ifdef RUNTIME_IMPLEMENTATION


#include <poll.h>
#include <stdarg.h>
#include <fcntl.h>


static int runtime_current_fiber = 0;
static MEMORY_SLICE(, RuntimeFiber) runtime_fibers  = {.count = 1};
static MEMORY_SLICE(, int) runtime_running_fibers   = {.count = 1};
static MEMORY_SLICE(, int) runtime_waiting_fibers   = {0};
static MEMORY_SLICE(, int) runtime_stopped_fibers   = {0};
static MEMORY_SLICE(, struct pollfd) runtime_polls  = {0};


int runtime_main(void)
{
    // Yield until all running or waiting fibers are finished
    while (runtime_running_fibers.count > 1 || runtime_waiting_fibers.count > 1)
        runtime_yield();
    return 0;
}


int runtime_id(void)
{
    // Dereference the current fiber from the list of running fibers
    return runtime_running_fibers.items[runtime_current_fiber];
}


void* runtime_alloc(int size)
{
    // Lazily initialize the first fiber if we are allocating memory globally
    if (runtime_fibers.count == 1 && runtime_fibers.capacity == 0) {
        runtime_fibers.items = malloc(sizeof(RuntimeFiber));
        runtime_fibers.items[0] = (RuntimeFiber){0};
        runtime_fibers.items[0].memory = memory_arena(MEMORY_DEFUALT_ARENA_SIZE);
        runtime_fibers.capacity = 1;
        runtime_running_fibers.items = malloc(sizeof(int));
        runtime_running_fibers.items[0] = 0;
        runtime_running_fibers.capacity = 1;
    }

    // Ensure that we have an arena for the current fiber
    RuntimeFiber* fiber = &runtime_fibers.items[runtime_id()];
    if (fiber->memory == NULL) {
        int capacity = MEMORY_DEFUALT_ARENA_SIZE > size ? MEMORY_DEFUALT_ARENA_SIZE : size;
        fiber->memory = memory_arena(capacity);
    }

    // Allocate memory using the Memory feature
    return memory_alloc(fiber->memory, size);
}


int runtime_unblock_fd(int fd)
{
    return fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
}


void runtime_start(void (*fn)(void*), void *arg)
{
    int fiber_id;

    // Check stopped fibers for an available fiber id
    if (runtime_stopped_fibers.count > 0) {
        fiber_id = runtime_stopped_fibers.items[--runtime_stopped_fibers.count];
    } else {
        memory_slice_append(NULL, &runtime_fibers, ((RuntimeFiber){0}));
        fiber_id = runtime_fibers.count - 1;
        runtime_fibers.items[fiber_id].memory = memory_arena(MEMORY_DEFUALT_ARENA_SIZE);

        // Allocate stack with a guard page
        void *stack = mmap(NULL, RUNTIME_FIBER_STACK_SIZE + getpagesize(), PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (stack == MAP_FAILED) {
            perror("[ERROR] Failed to allocate coroutine stack");
            exit(1);
        }

        // Enable read/write permissions for the stack, leaving the first page protected
        mprotect(stack + getpagesize(), RUNTIME_FIBER_STACK_SIZE, PROT_READ | PROT_WRITE);
        runtime_fibers.items[fiber_id].registers = stack + getpagesize() + RUNTIME_FIBER_STACK_SIZE;
    }

    void** pointer = (void**)(runtime_fibers.items[fiber_id].registers - sizeof(void*));

    // Setting up the fiber stack
    *(--pointer) = runtime_stop;  // Return pointer
    *(--pointer) = fn;            // Function to execute
    *(--pointer) = arg;           // First argument (in %rdi)
    *(--pointer) = NULL;          // %rbp (Base pointer)
    *(--pointer) = NULL;          // %rbx
    *(--pointer) = NULL;          // %r12
    *(--pointer) = NULL;          // %r13
    *(--pointer) = NULL;          // %r14
    *(--pointer) = NULL;          // %r15

    // Set the stack pointer for the process
    runtime_fibers.items[fiber_id].stack_pointer = pointer;

    // Append to list of running fibers
    memory_slice_append(NULL, &runtime_running_fibers, fiber_id);
}


void __attribute__((naked)) runtime_yield(void)
{
    asm(
    "    pushq %rdi\n"
    "    pushq %rbp\n"
    "    pushq %rbx\n"
    "    pushq %r12\n"
    "    pushq %r13\n"
    "    pushq %r14\n"
    "    pushq %r15\n"
    "    movq %rsp, %rdi\n"
    "    jmp _runtime_yield\n");
}


void _runtime_yield(void *rsp)
{
    // Pickup from jump in public facing function where the first arg
    // (aka %rdi) is the pointer to the return address that we can use
    // as the stack pointer for our current process. Then continue to
    // the next process.
    int fiber_id = runtime_running_fibers.items[runtime_current_fiber++];
    runtime_fibers.items[fiber_id].stack_pointer = rsp;
    runtime_next();
}


void __attribute__((naked)) runtime_read(int fd)
{
    (void)fd; asm(
    "    pushq %rdi\n"
    "    pushq %rbp\n"
    "    pushq %rbx\n"
    "    pushq %r12\n"
    "    pushq %r13\n"
    "    pushq %r14\n"
    "    pushq %r15\n"
    "    movq %rdi, %rdi\n"
    "    movq %rsp, %rsi\n"
    "    jmp _runtime_read\n");
}


void _runtime_read(int fd, void *rsp)
{
    // Pickup from jump in public facing function where the first arg
    // (aka %rdi) is the file descriptor and the second arg (aka %rsi) 
    // is the pointer to the return address that we can use as the
    // stack pointer for our current process.
    int fiber_id = runtime_running_fibers.items[runtime_current_fiber];
    runtime_fibers.items[fiber_id].stack_pointer = rsp;

    // Creating a pollfd for the file descriptor in read normal mode
    struct pollfd poll = {.fd = fd, .events = POLLRDNORM};
    memory_slice_append(NULL, &runtime_polls, poll);

    // We are not incrementing the current process like in
    // the yield function because this function is moved to the list
    // of waiting processes.
    memory_slice_append(NULL, &runtime_waiting_fibers, fiber_id);
    memory_slice_remove(&runtime_running_fibers, runtime_current_fiber);

    // Continue on to the next running process
    runtime_next();
}


void __attribute__((naked)) runtime_write(int fd)
{
    (void)fd; asm(
    "    pushq %rdi\n"
    "    pushq %rbp\n"
    "    pushq %rbx\n"
    "    pushq %r12\n"
    "    pushq %r13\n"
    "    pushq %r14\n"
    "    pushq %r15\n"
    "    movq %rdi, %rdi\n"
    "    movq %rsp, %rsi\n"
    "    jmp _runtime_write\n");
}


void _runtime_write(int fd, void *rsp)
{
    // Pickup from jump in public facing function where the first arg
    // (aka %rdi) is the file descriptor and the second arg (aka %rsi) 
    // is the pointer to the return address that we can use as the
    // stack pointer for our current process.
    int fiber_id = runtime_running_fibers.items[runtime_current_fiber];
    runtime_fibers.items[fiber_id].stack_pointer = rsp;

    // Creating a pollfd for the file descriptor in write normal mode
    struct pollfd poll = {.fd = fd, .events = POLLWRNORM};
    memory_slice_append(NULL, &runtime_polls, poll);

    // We are not incrementing the current process like in
    // the yield function because this function is moved to the list
    // of waiting processes.
    memory_slice_append(NULL, &runtime_waiting_fibers, fiber_id);
    memory_slice_remove(&runtime_running_fibers, runtime_current_fiber);

    // Continue on to the next running process
    runtime_next();
}


void runtime_resume(void* ptr)
{
    // This function is the inverse of the yield set of
    // functions. Rather than capturing the registers
    // we are interested in preserving, this function 
    // will restore the registers and return control of
    // to the current process's store stack pointer.
    (void)ptr; asm(
    "    movq %rdi, %rsp\n"
    "    popq %r15\n"
    "    popq %r14\n"
    "    popq %r13\n"
    "    popq %r12\n"
    "    popq %rbx\n"
    "    popq %rbp\n"
    "    popq %rdi\n"
    "    ret\n");
}


void runtime_next(void)
{
    // Switch to the next running coroutine
    if (runtime_polls.count > 0) {
        // if there are multiple running procs we want to not block
        int timeout = runtime_running_fibers.count > 1 ? 0 : -1;
        int result = poll(runtime_polls.items, runtime_polls.count, timeout);
        if (result < 0) {
            runtime_logf("[ERROR] poll failed\n");
            exit(1);
        }

        // Wake up the first sleeping coroutine
        for (int i = 0; i < runtime_polls.count;) {
            if (runtime_polls.items[i].revents) {
                int proc_id = runtime_waiting_fibers.items[i];
                memory_slice_remove(&runtime_polls, i);
                memory_slice_remove(&runtime_waiting_fibers, i);
                memory_slice_append(NULL, &runtime_running_fibers, proc_id);
            } else { ++i; }
        }
    }

    // Ensure coroutines continue executing
    if (runtime_running_fibers.count > 0) {
        runtime_current_fiber %= runtime_running_fibers.count;
        runtime_resume(runtime_fibers.items[runtime_running_fibers.items[runtime_current_fiber]].stack_pointer);
    }
}


void runtime_stop(void)
{
    int fiber_id = runtime_running_fibers.items[runtime_current_fiber];
    if (fiber_id == 0) {
        runtime_logf("[ERROR] Main coroutine with id 0 should never finish\n");
        exit(1);
    }

    RuntimeFiber running_fiber = runtime_fibers.items[fiber_id];
    memory_destroy(running_fiber.memory);

    memory_slice_append(NULL, &runtime_stopped_fibers, fiber_id);
    memory_slice_remove(&runtime_running_fibers, runtime_current_fiber);

    if (runtime_polls.count > 0) {
        int timeout = runtime_running_fibers.count > 1 ? 0 : -1;
        int result = poll(runtime_polls.items, runtime_polls.count, timeout);
        if (result < 0) {
            runtime_logf("[ERROR] poll failed\n");
            exit(1);
        }

        for (int i = 0; i < runtime_polls.count;) {
            if (runtime_polls.items[i].revents) {
                int ctx = runtime_waiting_fibers.items[i];
                memory_slice_remove(&runtime_polls, i);
                memory_slice_remove(&runtime_waiting_fibers, i);
                memory_slice_append(NULL, &runtime_running_fibers, ctx);
            } else { i++; }
        }
    }

    // Ensure we don't stop if there's at least one coroutine available
    if (runtime_running_fibers.count == 0 && runtime_waiting_fibers.count > 0) {
        memory_slice_append(NULL, &runtime_running_fibers, runtime_waiting_fibers.items[0]);
        memory_slice_remove(&runtime_waiting_fibers, 0);
        memory_slice_remove(&runtime_polls, 0);
    }

    if (runtime_running_fibers.count > 0) {
        runtime_current_fiber %= runtime_running_fibers.count;
        fiber_id = runtime_running_fibers.items[runtime_current_fiber];
        runtime_resume(runtime_fibers.items[fiber_id].stack_pointer);
    }
}


char* runtime_sprintf(char *fmt, ...)
{
    va_list args;

    // Count the size of the string to allocate memory
    va_start(args, fmt);
        int count = vsnprintf(NULL, 0, fmt, args);
    va_end(args);

    // Allocating memory in our current process arena
    char *string = runtime_alloc(count + 1);
    if (string == NULL) return NULL;

    // Performing actual print opperation to the string
    va_start(args, fmt);
        vsnprintf(string, count + 1, fmt, args);
    va_end(args);

    return string;
}


void runtime_logf(char *fmt, ...)
{
    va_list args;

    // Count the size of the string to allocate memory
    va_start(args, fmt);
        int count = vsnprintf(NULL, 0, fmt, args);
    va_end(args);

    // Allocating memory in our current process arena
    char *string = runtime_alloc(count + 1);
    if (string == NULL) return;

    // Performing actual print opperation to the string
    va_start(args, fmt);
        vsnprintf(string, count + 1, fmt, args);
    va_end(args);

    fprintf(stderr, "%s", string);
    fflush(stderr);
}



#endif // RUNTIME_IMPLEMENTATION
#endif // RUNTIME_HEADER
/** data.h - Dynamic data types for our application.

    @author:  Connor McCutcheon <connor.mccutcheon95@gmail.com>
    @date:    2025-03-03
    @version  0.1.0 
    @license: MIT
*/


#ifndef DATA_HEADER
#define DATA_HEADER


#include <stdbool.h>


// TODO: test these values
#define DATA_DEFAULT_LIST_CAPACITY 64
#define DATA_DEFAULT_DICT_CAPACITY 40


typedef struct DataValue {
    enum {
        DATA_EMPTY,
        DATA_BOOLEAN,
        DATA_INTEGER,
        DATA_NUMBER,
        DATA_STRING,
        DATA_TUPLE,
        DATA_LIST,
        DATA_DICT,
    } type;

    union {

        bool boolean;
        int integer;
        double decimal;
        char* string;

        struct DataTuple {
            struct DataValue* left;
            struct DataValue* right;
        }* tuple;

        struct DataList{
            struct DataValue** items;
            struct DataIndex {
                struct DataIndex* next;
                int index;
            }* available;
            int count;
            int capacity;
        }* list;

        struct DataDict {
            struct DataEntry {
                struct DataValue* value;
                char* key;
                unsigned long int hash;
            } **entries;
            struct DataIndex* indexes;
            int count;
            int capacity;
        }* dict;

    };
} DataValue;


// Data Type Constructors

DataValue* data_empty(void);

DataValue* data_boolean(bool boolean);

DataValue* data_integer(int integer);

DataValue* data_number(double decimal);

DataValue* data_string(char* string);

DataValue* data_tuple(DataValue* left, DataValue* right);

DataValue* data_list(DataValue* head, ...);

DataValue* data_dict(struct DataEntry* head, ...);


// Data List Functions

int data_list_prepend(DataValue* value, DataValue* value);

int data_list_append(DataValue* value, DataValue* value);

DataValue* data_list_get(DataValue* value, int index);

DataValue* data_list_remove(DataValue* value, int index);


// Data Dict Functions

struct DataEntry* data_entry(char* key, DataValue* value);

unsigned long int data_hash(char* s);

void data_dict_set(DataValue* value, char* key, DataValue* item);

DataValue* data_dict_get(DataValue* value, char* key);


// Data Helper Macros
#define DATA_END NULL


#ifdef DATA_IMPLEMENTATION


DataValue* data_empty(void)
{
    DataValue* value = runtime_alloc(sizeof(DataValue));
    value->type = DATA_EMPTY;
    return value;
}


DataValue* data_boolean(bool boolean)
{
    DataValue* value = data_empty();
    value->type = DATA_BOOLEAN;
    value->boolean = boolean;
    return value;
}


DataValue* data_integer(int integer)
{
    DataValue* value = data_empty();
    value->type = DATA_INTEGER;
    value->integer = integer;
    return value;
}


DataValue* data_number(double decimal)
{
    DataValue* value = data_empty();
    value->type = DATA_NUMBER;
    value->decimal = decimal;
    return value;
}


DataValue* data_string(char* string)
{
    DataValue* value = data_empty();
    value->type = DATA_STRING;
    value->string = string;
    return value;
}


DataValue* data_tuple(DataValue* left, DataValue* right)
{
    DataValue* value = data_empty();
    value->type = DATA_TUPLE;
    value->tuple = runtime_alloc(sizeof(struct DataValue*) * 2);
    if (left == NULL) left = data_empty();
    value->tuple->left = left;
    if (right == NULL) right = data_empty();
    value->tuple->right = right;
    return value;
}


DataValue* data_list(DataValue* head, ...)
{
    DataValue* value = data_empty();
    value->type = DATA_LIST;

    value->list = runtime_alloc(sizeof(struct DataList));
    value->list->items = runtime_alloc(sizeof(DataValue*) * 64);
    value->list->count = 0;
    value->list->capacity = DATA_DEFAULT_LIST_CAPACITY;
    value->list->available = NULL;

    va_list args;
    va_start(args, head);
        data_list_append(value, head);
        while (true) {
            DataValue* item = va_arg(args, DataValue*);
            if (item == NULL) break;
            if (item->type == DATA_EMPTY) break;
            data_list_append(value, item);
        }
    va_end(args);

    return value;
}


DataValue* data_dict(struct DataEntry* head, ...)
{
    DataValue* value = data_empty();
    value->type = DATA_DICT;

    value->dict = runtime_alloc(sizeof(struct DataDict));
    value->dict->entries = runtime_alloc(sizeof(struct DataEntry*) * DATA_DEFAULT_DICT_CAPACITY);
    value->dict->count = 0;
    value->dict->capacity = DATA_DEFAULT_DICT_CAPACITY;
    value->dict->indexes = NULL;

    if (head == NULL) return value;

    va_list args;
    va_start(args, head);
        data_dict_set(value, head->key, head->value);
        while (true) {
            struct DataEntry* item = va_arg(args, struct DataEntry*);
            if (item == NULL) break;
            data_dict_set(value, item->key, item->value);
        }
    va_end(args);
    return value;
}


int data_list_prepend(DataValue* value, DataValue* value)
{
    if (value->type != DATA_LIST) return 0;

    struct DataList* list = value->list;
    if (list->count >= list->capacity) {
        list->capacity *= 2;
        list->items = runtime_alloc(sizeof(DataValue*) * list->capacity);
    }

    if (list->items[0] != NULL)
        for (int i = list->capacity - 1; i > 0; i--) {
            list->items[i] = list->items[i - 1];
        }

    list->items[0] = value;
    list->count += 1;
    return 0;
}


int data_list_append(DataValue* value, DataValue* value)
{
    if (value->type != DATA_LIST) return 0;

    struct DataList* list = value->list;
    if (list->count >= list->capacity) {
        list->capacity *= 2;
        list->items = runtime_alloc(sizeof(DataValue*) * list->capacity);
    }

    int index;
    if (list->available != NULL) {
        index = list->available->index;
        list->available = list->available->next;
    } else {
        index = list->count++;
    }

    list->items[index] = value;
    return list->count - 1;
}


DataValue* data_list_remove(DataValue* value, int index)
{
    if (value == NULL) return data_empty();
    if (value->type != DATA_LIST) return data_empty();

    struct DataList* list = value->list;
    if (list == NULL) return data_empty();

    list->available = runtime_alloc(sizeof(struct DataIndex));
    list->available->index = index;
    list->available->next = list->available;

    DataValue* value = list->items[index];
    list->items[index] = NULL;
    list->count -= 1;
    return value;
}


DataValue* data_list_get(DataValue* value, int index)
{
    if (list == NULL) return data_empty();
    if (value->type != DATA_LIST) return data_empty();

    struct DataList* list = value->list;
    if (list == NULL) return data_empty();

    DataValue* value = list->items[index];
    if (value == NULL) return data_empty();

    return value;
}


void data_print_list(DataValue* value)
{
    if (list == NULL) return;
    if (value->type != DATA_LIST) return;

    struct DataList* list = value->list;
    if (list == NULL) return;

    for (int i = 0; i < list->count; i++) {
        printf("%d: ", i);
        printf("%p", list->items[i]);
        printf("\n");
    }
}

void data_print_dict(DataValue* value)
{
    if (dict == NULL) return;
    if (value->type != DATA_DICT) return;
    struct DataDict* dict = value->dict;

    for (int i = 0; i < dict->count; i++) {
        if (dict->entries[i] == NULL) continue;
        printf("%s: ", dict->entries[i]->key);
        printf("%p", dict->entries[i]->value);
        printf("\n");
    }
}


struct DataEntry* data_entry(char* key, DataValue* value)
{
    struct DataEntry* entry = runtime_alloc(sizeof(struct DataEntry));
    entry->key = key;
    entry->value = value;
    entry->hash = data_hash(key);
    return entry;
}


// Using Ben Hoyt's hashing implementation.
//    https://benhoyt.com/writings/hash-table-in-c/


#define DATA_HASH_OFFSET 14695981039346656037UL
#define DATA_HASH_PRIME  1099511628211UL


unsigned long int data_hash(char *s)
{
    unsigned long int hash = DATA_HASH_OFFSET;
    for (char *c = s; *c != '\0'; c++)
        hash = DATA_HASH_PRIME * (hash ^ (unsigned long int)(unsigned char)(*c));
    return hash;
}


void data_dict_set(DataValue* value, char* key, DataValue* item)
{
    if (value->type != DATA_DICT) return;

    struct DataDict* dict = value->dict;
    struct DataEntry* entry = data_entry(key, item);

    unsigned long long int hash = entry->hash;
    struct DataIndex* index = runtime_alloc(sizeof(struct DataIndex));
    index->next = dict->indexes;
    index->index = hash % dict->capacity;
    while (dict->entries[index->index] != NULL) {
        if (dict->entries[index->index]->hash == hash) {
            dict->entries[index->index]->value = item;
            return;
        }
        index->index = (5 * index->index + hash + 1) % dict->capacity;
        hash >>= 5;
    }

    dict->entries[index->index] = entry;
    dict->indexes = index;
    dict->count += 1;
    return;
}


DataValue* data_dict_get(DataValue* value, char* key)
{
    if (value->type != DATA_DICT) return data_empty();

    struct DataDict* dict = value->dict;
    unsigned long long int hash = data_hash(key);
    int index = hash % dict->capacity;
    while (dict->entries[index] != NULL) {
        if (dict->entries[index]->hash == hash) 
            return dict->entries[index]->value;
        index = (5 * index + hash + 1) % dict->capacity;
        hash >>= 5;
    }

    return dict->entries[index]->value;
}


#endif // DATA_IMPLEMENTATION
#endif // DATA_HEADER
